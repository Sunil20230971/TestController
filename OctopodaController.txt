/***************************************************************************************
 * COPYRIGHT NOTICE                                                                      *

 * Copyright @ 2023 CredenTek Software & Consultancy Pvt Ltd. All rights reserved.       *

 * These materials are confidential and proprietary to CredenTek Software & Consultancy  *

 * Pvt Ltd and no part of these materials should be reproduced, published, transmitted   *

 * or distributed in any form or by any means, electronic, mechanical, photocopying,     *

 * recording or otherwise, or stored in any information storage or retrieval system of   *

 * any nature, nor should the materials be disclosed to third parties or used in any     *

 * other manner for which this is not authorized, without the prior express written      *

 * authorization of CredenTek Software & Consultancy Pvt Ltd.                            *

 ****************************************************************************************/
/**********************************************************************
 *
 * Module Name 	:
 *
 * File Name 	: OctopodaController.java
 *
 * Description 	: Controller Class for workflow ApI.
 *
 * 				Version Control Block
 * 				---------------------
 * Date 			Version 	Author 			Reviewer 		Description
 * --------- 	-------- 	--------------- --------------- ------------ 
 * 02-01-2023	0		Octopoda Team							Base Version
 **********************************************************************/
package com.credentek.octopoda.workflow;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jbpm.services.api.ProcessService;
import org.jbpm.services.api.RuntimeDataService;
import org.jbpm.services.api.TaskNotFoundException;
import org.jbpm.services.api.UserTaskService;
import org.jbpm.workflow.instance.WorkflowProcessInstance;
import org.kie.api.task.model.Status;
import org.kie.api.task.model.Task;
import org.kie.api.task.model.TaskData;
import org.kie.api.task.model.TaskSummary;
import org.kie.internal.query.QueryFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.credentek.octopoda.common.ProcessMetaData;
import com.credentek.octopoda.common.ResponseData;
import com.credentek.octopoda.common.RetStatus;
import com.credentek.octopoda.common.TaskAuditTrail;
import com.credentek.octopoda.common.TaskDetails;
import com.credentek.octopoda.common.Utils;
import com.credentek.octopoda.service.WorkFlowAuditTrailService;

@RestController
public class OctopodaController {

	/*
	 * Methods implemented : 1. launchNewProcess 2. fetchUnallocatedTasks 3.
	 * findTasksByProcessId 4. getProcessAuditTrail 5. fetchMyTasks 6. claimTask 7.
	 * completeTask 8. reassignTask 
	 */

	String deploymentID = "octopoda-kjar-1_0-SNAPSHOT";
	//String processID = "com.credentek.Octopoda.bpmn";
	String systemMakerID = "system1";
	String cbcProcessId = "com.credentek.Octopoda.cbc.bpmn";
	String processID = "com.credentek.octopoda.StudentEnrollment.bpmn"; //com.credentek.octopoda.datacc.bpmn    com.credentek.octopoda.simple.bpmn   com.credentek.octopoda.StudentEnrollment.bpmn
	
	@Autowired
	private ProcessService processService;
	@Autowired
	private RuntimeDataService runtimeDataService;
	@Autowired
	private UserTaskService userTaskService;

	@Autowired
	private WorkFlowAuditTrailService WorkFlowAuditTrailService;

	private static final Logger logger = LogManager.getLogger(OctopodaController.class);
	
	// @GetMapping("/launchNewProcess")
	@PostMapping(value = "/launchNewProcess")
	public ResponseEntity<ResponseData> launchNewProcess(@RequestBody Map<String, String> inputData) throws Exception {
		logger.info("In LaunchNewProcess of OctopodaController");
		String Name = "";
		String Income = "";
		String Amount = "";
		ResponseData glpdRespObj = new ResponseData();
		TaskDetails taskDtlObj = new TaskDetails();
		List<TaskDetails> taskDtlList = new ArrayList<TaskDetails>();

		List<Object[]> batchDetails = null;
		Map<String, Object> params = new HashMap<String, Object>();
		int counter = 0;
		ProcessMetaData lProcessMetaData = new ProcessMetaData();
		RetStatus lRetStatus = new RetStatus();

		logger.info(inputData.toString());

		Name = inputData.get("Name");
        Income =inputData.get("Income");
        Amount =inputData.get("Amount");
		batchDetails = WorkFlowAuditTrailService.fetchBatchDetails(Name);

		lProcessMetaData.setF1(Name);
		lProcessMetaData.setF2(Income);
		lProcessMetaData.setF3(Amount);

		
		// For only valid Batch process will be launch
		if (batchDetails.size() >= 0) {
			params.put("gRetStatus", lRetStatus);
			params.put("gProcessMetaData", lProcessMetaData);

			Long processInstanceId = processService.startProcess(deploymentID, processID, params);

			WorkflowProcessInstance pInst = (WorkflowProcessInstance) processService
					.getProcessInstance(processInstanceId);

			logger.info("Process Launch For BatchNo:" + Name + " PID[" + pInst.getId() + "]");
			logger.info("PID[" + pInst.getId() + "]:State=" + pInst.getState() + ",Details=" + pInst.toString());

			WorkFlowAuditTrailService.insertIntoBatchAuditTrail(pInst.getId(), lProcessMetaData, "I", "Workflow strt",
					systemMakerID, 1);

			taskDtlObj.setProcessID(pInst.getId());
			taskDtlObj.setCurrStatus(String.valueOf(pInst.getState()));
			taskDtlObj.setF1(lProcessMetaData.toString());

			taskDtlList.add(taskDtlObj);
			glpdRespObj.setData(taskDtlList);
			glpdRespObj.setErrorMsg("success");
			glpdRespObj.setErrorCode("0");
			glpdRespObj.setCount(counter);

		}
		logger.info("Exit From Admission Process of OctopodaController");
		return ResponseEntity.status(HttpStatus.CREATED).body(glpdRespObj);
	}
	
	
	@PostMapping(value = "/launchNewProcessForStudent")
	public ResponseEntity<ResponseData> launchNewProcessForStudent(@RequestBody Map<String, String> inputData) throws Exception {
		logger.info("In launchNewProcessForStudent of OctopodaController");
		String name = "";
		String age = "";
		String standard = "";
		String mobile = "";
		ResponseData glpdRespObj = new ResponseData();
		TaskDetails taskDtlObj = new TaskDetails();
		List<TaskDetails> taskDtlList = new ArrayList<TaskDetails>();

		List<Object[]> batchDetails = null;
		Map<String, Object> params = new HashMap<String, Object>();
		int counter = 0;
		ProcessMetaData lProcessMetaData = new ProcessMetaData();
		RetStatus lRetStatus = new RetStatus();

		logger.info(inputData.toString());

		name = inputData.get("Name");
        age =inputData.get("Age");
        standard =inputData.get("Class");
        mobile =inputData.get("Mobile");
		batchDetails = WorkFlowAuditTrailService.fetchBatchDetails(name);

		lProcessMetaData.setF1(name);
		lProcessMetaData.setF2(age);
		lProcessMetaData.setF3(standard);
		lProcessMetaData.setF4(mobile);
		
		// For only valid Batch process will be launch
		if (batchDetails.size() >= 0) {
			params.put("gRetStatus", lRetStatus);
			params.put("gProcessMetaData", lProcessMetaData);

			Long processInstanceId = processService.startProcess(deploymentID, processID, params);

			WorkflowProcessInstance pInst = (WorkflowProcessInstance) processService
					.getProcessInstance(processInstanceId);

			logger.info("Process Launch For Class :" + standard + " PID[" + pInst.getId() + "]");
			logger.info("PID[" + pInst.getId() + "]:State=" + pInst.getState() + ",Details=" + pInst.toString());

			WorkFlowAuditTrailService.insertIntoBatchAuditTrail(pInst.getId(), lProcessMetaData, "I", "Workflow strt",
					systemMakerID, 1);

			taskDtlObj.setProcessID(pInst.getId());
			taskDtlObj.setCurrStatus(String.valueOf(pInst.getState()));
			taskDtlObj.setF1(lProcessMetaData.toString());

			taskDtlList.add(taskDtlObj);
			glpdRespObj.setData(taskDtlList);
			glpdRespObj.setErrorMsg("success");
			glpdRespObj.setErrorCode("0");
			glpdRespObj.setCount(counter);		
			
		}
		logger.info("Exit From Admission Process of OctopodaController");
		return ResponseEntity.status(HttpStatus.CREATED).body(glpdRespObj);
	}
	
	

	@PostMapping(value = "/fetchUnallocatedTasks")
	public ResponseEntity<ResponseData> fetchUnallocatedTasks(@RequestBody Map<String, String> inputData) {
		logger.info("In fetchUnallocatedTasks of OctopodaController");
		ResponseData glpdRespObj = new ResponseData();
		QueryFilter queryFilter;
		List<TaskDetails> freeTaskList = new ArrayList<TaskDetails>();
		String queueID = "";
		String executorID = "";
		String branchCode = "";
		int counter = 0;
		if (inputData.containsKey("queueID")) {
			queueID = inputData.get("queueID");
		}
		if (inputData.containsKey("executorID")) {
			String decryptexecutorID = Utils.decryptText(inputData.get("executorID"));
			executorID = decryptexecutorID.toUpperCase();
		}
		if (inputData.containsKey("branchCode")) {
			branchCode = inputData.get("branchCode");
		}

		if (!queueID.isEmpty()) // if queue name is specified, fetch only specific queue tasks.
		{
			Map<String, Object> params = new HashMap<String, Object>();
			params.put("name", queueID);
			queryFilter = new QueryFilter("t.name = :name", params, "t.id", false);
			queryFilter.setCount(1000);
		} else {
			queryFilter = new QueryFilter(0, 100, "t.id", false);
		}

		List<TaskSummary> taskSummaries = runtimeDataService.getTasksAssignedAsPotentialOwner(executorID, queryFilter);

		// taskSummaries.forEach(taskSummary->
		for (TaskSummary taskSummary : taskSummaries) {
			Status status = taskSummary.getStatus();

			logger.info("fetchFreeTasks=" + taskSummary.toString());

			if ((status == Status.Created || status == Status.Ready || status == Status.Reserved)
					&& !"M9900".equals(taskSummary.getName())) // Ready = started but multiple potential owners.
																// Reserved = started and only one potential owner
			{
				Long processInstanceId = taskSummary.getProcessInstanceId();
				Long taskID = taskSummary.getId();
				counter++;
				logger.info("PID[" + processInstanceId + "], TID=[" + taskID + "]");

				try {
					WorkflowProcessInstance pInst = (WorkflowProcessInstance) processService
							.getProcessInstance(processInstanceId);
					ProcessMetaData lProcessMetaData = (ProcessMetaData) pInst.getVariable("gProcessMetaData");
					RetStatus lRetStatus = (RetStatus) pInst.getVariable("gRetStatus");
					// Branch Code filter Added
					if (branchCode.equals("") || branchCode.equals(lProcessMetaData.getF2())) // compare with queueName
					{
						TaskDetails myTaskDetails = new TaskDetails();

						myTaskDetails.build(lProcessMetaData, lRetStatus, userTaskService.getTask(taskID),
								WorkFlowAuditTrailService);

						freeTaskList.add(myTaskDetails);
					}
				} catch (Exception e) {
					logger.error("Error while Fetching Free Task", e);
				}
			}
		}

		logger.info("Total No. Of Unallocated Task Fetched :" + freeTaskList.size());

		glpdRespObj.setData(freeTaskList);

		if (freeTaskList.size() > 0)
			glpdRespObj.setErrorMsg("success");
		else
			glpdRespObj.setErrorMsg("No Task is available");

		glpdRespObj.setErrorCode("0");
		glpdRespObj.setCount(counter);

		logger.info("Exit from fetchUnallocatedTasks of OctopodaController");
		return ResponseEntity.status(HttpStatus.OK).body(glpdRespObj);
	}

	// @RequestMapping(value="/findTasksByProcessId", method = RequestMethod.GET,
	// produces = MediaType.APPLICATION_JSON_VALUE)
	@PostMapping(value = "/findTasksByProcessId")
	public ResponseEntity<ResponseData> findTasksByProcessId(@RequestBody Map<String, String> inputData)
			throws Exception {
		logger.info("In findTasksByProcessId of OctopodaController");
		ResponseData glpdRespObj = new ResponseData();

		long processInstanceId = Long.valueOf(inputData.get("processInstanceId"));

		List<Long> taskList = runtimeDataService.getTasksByProcessInstanceId(processInstanceId);
		List<TaskDetails> allTaskList = new ArrayList<TaskDetails>();
		int counter = 0;
		logger.info("Finding Tasks For ProcessId :" + processInstanceId);
		for (Long taskID : taskList) {
			counter++;
			Task myTask = userTaskService.getTask(taskID);
			TaskData taskData = myTask.getTaskData();
			String taskStatus = Utils.safeString(taskData.getStatus());
			if ("Ready".equals(taskStatus) || "InProgress".equals(taskStatus) || "Created".equals(taskStatus)) {
				logger.info("PID[" + processInstanceId + "], TID=[" + taskID + "]");
				WorkflowProcessInstance pInst = (WorkflowProcessInstance) processService
						.getProcessInstance(processInstanceId);
				try {
					ProcessMetaData lProcessMetaData = (ProcessMetaData) pInst.getVariable("gProcessMetaData");
					RetStatus lRetStatus = (RetStatus) pInst.getVariable("gRetStatus");
					TaskDetails myTaskDetails = new TaskDetails();
					myTaskDetails.build(lProcessMetaData, lRetStatus, myTask, WorkFlowAuditTrailService);
					allTaskList.add(myTaskDetails);

				} catch (Exception e) {
					logger.error("Error while Fetching Free Task", e);
					glpdRespObj.setErrorMsg("Error while Fetching Free Task");
					glpdRespObj.setErrorCode("1");

					return ResponseEntity.status(HttpStatus.OK).body(glpdRespObj);
				}
			}
			logger.info("Total No Tasks Found For ProcessId :" + processInstanceId + " Is - " + allTaskList.size());
		}

		glpdRespObj.setData(allTaskList);
		glpdRespObj.setErrorMsg("success");
		glpdRespObj.setErrorCode("0");
		glpdRespObj.setCount(counter);

		return ResponseEntity.status(HttpStatus.OK).body(glpdRespObj);
	}

	@PostMapping(value = "/getProcessAuditTrail")
	public ResponseEntity<ResponseData> getProcessAuditTrail(@RequestBody Map<String, String> inputData)
			throws Exception {
		logger.info("In getProcessAuditTrail of OctopodaController");

		ResponseData glpdRespObj = new ResponseData();
		long processInstanceId = Long.valueOf(inputData.get("processInstanceId"));
		int counter = 0;
		QueryFilter queryFilter;
		List<TaskAuditTrail> taskAuditTrailList = new ArrayList<TaskAuditTrail>();
		queryFilter = new QueryFilter(0, 100, "t.id", true);
		try {
			List<Status> status = new ArrayList<Status>();
			status.add(Status.Created);
			status.add(Status.Ready);
			status.add(Status.Reserved);
			status.add(Status.InProgress);
			status.add(Status.Suspended);
			status.add(Status.Completed);
			status.add(Status.Error);
			status.add(Status.Exited);
			status.add(Status.Failed);

			List<TaskSummary> taskSummaries = runtimeDataService.getTasksByStatusByProcessInstanceId(processInstanceId,
					status, queryFilter);

			// taskSummaries.forEach(taskSummary->
			for (TaskSummary taskSummary : taskSummaries) {
				TaskAuditTrail auditTrail = new TaskAuditTrail();
				counter++;
				auditTrail.build(taskSummary);

				taskAuditTrailList.add(auditTrail);
			}
			logger.info("taskAuditTrail=" + taskAuditTrailList.toString());

		} catch (Exception e) {
			glpdRespObj.setErrorMsg("Error : " + e.toString());
			glpdRespObj.setErrorCode("1");
			glpdRespObj.setCount(counter);
			return ResponseEntity.status(HttpStatus.OK).body(glpdRespObj);
		}

		glpdRespObj.setData(taskAuditTrailList);
		glpdRespObj.setErrorMsg("success");
		glpdRespObj.setErrorCode("0");
		glpdRespObj.setCount(counter);

		logger.info("Exit From getProcessAuditTrail of OctopodaController");

		return ResponseEntity.status(HttpStatus.OK).body(glpdRespObj);
	}

	@PostMapping(value = "/fetchMyTasks")
	public ResponseEntity<ResponseData> fetchMyTasks(@RequestBody Map<String, String> inputData) throws Exception {
		ResponseData glpdRespObj = new ResponseData();
		List<Status> statusArray = new ArrayList<Status>();
		List<TaskSummary> taskSummaries;
		int counter = 0;
		QueryFilter queryFilter;
		String flag = "";
		String executorID = "";
		String queueID = "";
		String queueName = "";
		List<TaskDetails> assignedTaskList = new ArrayList<TaskDetails>();
		Map<String, String> mapData = glpdRespObj.getDataMap();
		try {
			logger.info("In fetchMyTasks of OctopodaController");

			if (inputData.containsKey("flag")) {
				flag = inputData.get("flag");
			}
			if (inputData.containsKey("executorID")) {

				String decryptexecutorID = Utils.decryptText(inputData.get("executorID"));
				executorID = decryptexecutorID.toUpperCase();

			}
			if (inputData.containsKey("queueID")) {
				queueID = inputData.get("queueID");
			}
			if (inputData.containsKey("queueName")) {
				queueName = inputData.get("queueName");
			}
			logger.info("Fetching Tasks For Executor Id : " + executorID + ", Queue Id : " + queueID + ", Queue Name : "
					+ queueName + ", Flag : " + flag);

			if (!queueID.isEmpty()) // if queue name is specified, fetch only specific queue tasks.
			{
				Map<String, Object> params = new HashMap<String, Object>();
				params.put("name", queueID);
				queryFilter = new QueryFilter("t.name = :name", params, "t.id", false);
				queryFilter.setCount(1000);
			} else {
				queryFilter = new QueryFilter(0, 100, "t.id", false);
			}

			if (flag.equals("all")) {
				taskSummaries = runtimeDataService.getTasksOwned(executorID, queryFilter);
			} else {
				statusArray.add(Status.Reserved);
				statusArray.add(Status.InProgress);
				taskSummaries = runtimeDataService.getTasksOwnedByStatus(executorID, statusArray, queryFilter);
			}

			// taskSummaries.forEach(taskSummary->
			for (TaskSummary taskSummary : taskSummaries) {
				taskSummary.getStatus();

				Long processInstanceId = taskSummary.getProcessInstanceId();
				Long taskID = taskSummary.getId();

				String myQueueName = taskSummary.getDescription();

				if ("".equals(queueName) || myQueueName.equals(queueName)) // compare with queueName
				{
					counter++;
					logger.info("PID[" + processInstanceId + "], TID=[" + taskID + "]");
					try {
						WorkflowProcessInstance pInst = (WorkflowProcessInstance) processService
								.getProcessInstance(processInstanceId);
						ProcessMetaData lProcessMetaData = (ProcessMetaData) pInst.getVariable("gProcessMetaData");
						RetStatus lRetStatus = (RetStatus) pInst.getVariable("gRetStatus");

						TaskDetails myTaskDetails = new TaskDetails();

						myTaskDetails.build(lProcessMetaData, lRetStatus, userTaskService.getTask(taskID),
								WorkFlowAuditTrailService);
						assignedTaskList.add(myTaskDetails);
						if (mapData.containsKey(myTaskDetails.getCurrQueueDesc())) {
							int count = Integer.valueOf(mapData.get(myTaskDetails.getCurrQueueDesc()));
							mapData.put(myTaskDetails.getCurrQueueDesc(), String.valueOf(count + 1));
						} else {
							mapData.put(myTaskDetails.getCurrQueueDesc(), "1");
						}
					} catch (Exception e) {
						logger.error("Error while Fetching Free Task", e);

					}
				}
			}

			logger.info("Total No.Task Find: " + assignedTaskList.size() + " for Executor Id - " + executorID);

			glpdRespObj.setData(assignedTaskList);
			glpdRespObj.setErrorMsg("success");
			glpdRespObj.setErrorCode("0");
			glpdRespObj.setCount(counter);
			glpdRespObj.setDataMap(mapData);

			logger.info("Exit From fetchMyTasks of OctopodaController");
		} catch (Exception e) {
			logger.error("Exception - fetchMyTasks:", e);
		} catch (Throwable th) {
			logger.error("Throwable - fetchMyTasks:", th);
		}
		return ResponseEntity.status(HttpStatus.CREATED).body(glpdRespObj);
	}

	@PostMapping(value = "/claimTask")
	public ResponseEntity<ResponseData> claimTask(@RequestBody Map<String, String> inputData) throws Exception {
		logger.info("In Assign/claim task of OctopodaController");

		ResponseData glpdRespObj = new ResponseData();
		String taskIdList = "";
		String executorID = "";
		String[] taskIdArr;
		String decryptexecutorID = "";
		int counter = 0;
		int failCounter = 0;
		if (inputData.containsKey("taskID") && inputData.containsKey("executorID")) {
			taskIdList = inputData.get("taskID");
			decryptexecutorID = Utils.decryptText(inputData.get("executorID"));
			executorID = decryptexecutorID.toUpperCase();
		} else {

			glpdRespObj.setData(null);
			glpdRespObj.setErrorMsg("Error");
			glpdRespObj.setErrorCode("0");
			glpdRespObj.setCount(0);
			glpdRespObj.setDataMap(null);
			return ResponseEntity.status(HttpStatus.CREATED).body(glpdRespObj);
		}

		taskIdArr = taskIdList.split(",");

		glpdRespObj.setErrorMsg("success");
		glpdRespObj.setErrorCode("0");

		for (String currTaskId : taskIdArr) {
			try {
				long taskID = Long.valueOf(currTaskId);
				Boolean taskClaimFlag = false;

				Task myTask = userTaskService.getTask(taskID);
				TaskData taskData = myTask.getTaskData();

				WorkflowProcessInstance pInst = (WorkflowProcessInstance) processService
						.getProcessInstance(taskData.getProcessInstanceId());

				Status status = taskData.getStatus();
				ProcessMetaData lProcessMetaData = (ProcessMetaData) pInst.getVariable("gProcessMetaData");

				if (status == Status.Created) {
					userTaskService.activate(taskID, executorID);
					userTaskService.claim(taskID, executorID);
					userTaskService.start(taskID, executorID);

					taskClaimFlag = true;
					counter++;
				} else if (status == Status.Ready) {

					userTaskService.claim(taskID, executorID);
					userTaskService.start(taskID, executorID);

					taskClaimFlag = true;
					counter++;
				} else if (status == Status.Reserved) // no need to claim if already reserved
				{
					// userTaskService.claim(taskID, executorID);
					userTaskService.start(taskID, executorID);

					taskClaimFlag = true;
					counter++;
				} else {
					glpdRespObj.setErrorMsg("Error: " + status.toString());
					glpdRespObj.setErrorCode("1");
					failCounter++;
				}

				if (taskClaimFlag) {
					lProcessMetaData.setOwnerID(executorID);
					lProcessMetaData.setCurrTaskID(taskID);

					// WorkFlowAuditTrailService.claimProcessAuditTrail(pInst.getId(),lProcessMetaData,"P",myTask.getDescription(),executorID,0);
					// WorkFlowAuditTrailService.updateBatchCntrlDtl(pInst.getId(),
					// lProcessMetaData, "P", myTask.getDescription(), executorID);
					WorkFlowAuditTrailService.updateLeadCntrlDtl(pInst.getId(), lProcessMetaData, "P",
							myTask.getDescription(), executorID);
					// WorkFlowAuditTrailService.insertIntoBatchAuditTrail(pInst.getId(),
					// lProcessMetaData, "P", myTask.getDescription(), executorID, 0);

					if ("CB Data Correction Queue".equals(myTask.getDescription())
							|| "PCBC Queue".equals(myTask.getDescription())
							|| "Borrower CB Correction Queue".equals(myTask.getDescription())
							|| "Co-Borrower CB Correction Queue".equals(myTask.getDescription())
							|| "EM1 Correction Queue".equals(myTask.getDescription())
							|| "EM2 Correction Queue".equals(myTask.getDescription())
							|| "CB Check Initiation".equals(myTask.getDescription())
							|| "CB Check".equals(myTask.getDescription())) {

						WorkFlowAuditTrailService.insertIntoLeadAuditTrailByLeadId(lProcessMetaData,
								myTask.getDescription(), executorID, 1, pInst.getId());
					} else {
						WorkFlowAuditTrailService.insertIntoLeadAuditTrail(lProcessMetaData, lProcessMetaData.getF1(),
								myTask.getDescription(), executorID, 0);

						WorkFlowAuditTrailService.insertIntoBatchAuditTrail(pInst.getId(), lProcessMetaData, "P",
								myTask.getDescription(), executorID, 0);

					}
					logger.info("Task ID: " + taskID + " Successfully Assigned For Executor Id " + executorID);
				}
			} catch (TaskNotFoundException ex) {
				logger.info("ERROR", ex);
				failCounter++;
			} catch (NumberFormatException ex) {
				logger.info("ERROR", ex);
				failCounter++;
			} catch (Exception ex) {
				logger.info("ERROR", ex);
				failCounter++;
			}
		}

		if (failCounter > 0) {
			glpdRespObj.setErrorMsg(
					counter + " Task(s) Claimed Successfully! " + failCounter + " Task(s) Failed To Claim");
			if (counter == 0) {
				glpdRespObj.setErrorCode("1");
			}

		} else if (counter > 0) {
			glpdRespObj.setErrorMsg(counter + " Task(s) Claimed Successfully!");
			glpdRespObj.setErrorCode("0");
		}

		glpdRespObj.setData(null);
		glpdRespObj.setCount(counter);

		logger.info("Exit from Assign/claim task of OctopodaController");
		return ResponseEntity.status(HttpStatus.CREATED).body(glpdRespObj);
	}

	@PostMapping(value = "/completeTask")
	public ResponseEntity<ResponseData> completeTask(@RequestBody Map<String, String> inputData) {
		logger.info("In completeTask of OctopodaController");

		String executorID = "";
		long taskID = 0;
		int actionValue = 0;
		int counter = 0;

		ResponseData glpdRespObj = new ResponseData();
		TaskDetails taskDtl = new TaskDetails();
		List<TaskDetails> taskList = new ArrayList<TaskDetails>();
		Map<String, Object> params = new HashMap<String, Object>();
		String remarks = "";
		String decryptexecutorID = "";

		decryptexecutorID = Utils.decryptText(inputData.get("executorID"));
		executorID = decryptexecutorID.toUpperCase();

		taskID = Long.valueOf(inputData.get("taskID"));
		actionValue = Integer.valueOf(inputData.get("actionValue"));

		if (inputData.containsKey("remarks")) {
			remarks = inputData.get("remarks");
		}

		logger.info("Completing task : " + taskID + " Executor Id : " + executorID + " Action Value : " + actionValue);

		try {

			Task myTask = userTaskService.getTask(taskID);

			TaskData taskData = myTask.getTaskData();

			logger.info("completeTask:TID=[" + taskID + "]" + taskData.toString());

			Status status = taskData.getStatus();

			if (status == Status.InProgress) {
				glpdRespObj.setErrorMsg("Task Completed Successfully");
				glpdRespObj.setErrorCode("0");

				String taskName = myTask.getName();

				logger.info("taskName=" + taskName + ", taskDesc=" + myTask.getDescription());

				Long processInstanceId = taskData.getProcessInstanceId();
				WorkflowProcessInstance pInst = (WorkflowProcessInstance) processService
						.getProcessInstance(processInstanceId);
				
				logger.info("step1");

				ProcessMetaData myProcessMetaData = (ProcessMetaData) pInst.getVariable("gProcessMetaData");
				RetStatus myRetStatus = (RetStatus) pInst.getVariable("gRetStatus");
				logger.info("step2");

				myProcessMetaData.setCurrTaskID(taskID);
				logger.info("step3");

				if (taskName.equals("M100")) {
					myRetStatus.setM100Status(actionValue);
				} else if (taskName.equals("M110")) {
					myRetStatus.setM110Status(actionValue);
				} 

				params.put("lRetStatus", myRetStatus);
				params.put("lProcessMetaData", myProcessMetaData);

				logger.info("step5");

				
				userTaskService.complete(taskID, executorID, params);
				logger.info("step6");

				taskDtl.build(myProcessMetaData, myRetStatus, myTask, WorkFlowAuditTrailService);
				taskList.add(taskDtl);
				logger.info("step7");

				logger.info("PID[" + pInst.getId() + "]:State=" + pInst.getState() + ",Details=" + pInst.toString());
				logger.info("step8");

			} else {
				glpdRespObj.setErrorMsg("ERROR:" + status.toString());
				glpdRespObj.setErrorCode("1");
				logger.info("step9");

			}
		} catch (TaskNotFoundException ex) {
			logger.error("Error", ex);

			glpdRespObj.setErrorMsg("ERROR:Task not found");
			glpdRespObj.setErrorCode("1");
		} catch (Exception ex) {
			logger.error("Error", ex);

			glpdRespObj.setErrorMsg("ERROR: Technical Error");
			glpdRespObj.setErrorCode("1");
		}

		glpdRespObj.setData(taskList);
		glpdRespObj.setCount(counter);

		logger.info("Exit From completeTask of OctopodaController");

		return ResponseEntity.status(HttpStatus.CREATED).body(glpdRespObj);
	}

	@PostMapping(value = "/reassignTask")
	public ResponseEntity<ResponseData> unassignTask(@RequestBody Map<String, String> inputData) {
		logger.info("In reassignTask of OctopodaController");

		ResponseData glpdRespObj = new ResponseData();
		String executorID = "";
		long taskID = 0;
		String taskIdList = "";
		taskIdList = inputData.get("taskID");
		taskIdList = taskIdList.substring(0, taskIdList.length() - 1);
		if (inputData.containsKey("executorID")) {
			executorID = inputData.get("executorID");
		}

		try {
			String taskArr[] = taskIdList.split(",");
			for (String task : taskArr) {
				taskID = Utils.safeLong(task);
				Task myTask = userTaskService.getTask(taskID);
				TaskData taskData = myTask.getTaskData();
				Status status = taskData.getStatus();

				if (status == Status.InProgress || status == Status.Reserved) {
					String currentOwner = taskData.getActualOwner().getId().toUpperCase();

					logger.info(
							"Task Id : " + taskID + " Current Owner : " + currentOwner + "New Owner : " + executorID);

					if (executorID.isEmpty() || status == Status.Reserved) {
						userTaskService.release(taskID, currentOwner); // if task is reassigned to somone, it will go
																		// into state of Reserved. Now, first release it
																		// and then only can delegate
					}
					if (!executorID.isEmpty()) {
						userTaskService.delegate(taskID, currentOwner, executorID.toUpperCase());
					}

					glpdRespObj.setErrorMsg("Success");
					glpdRespObj.setErrorCode("0");
				} else {
					glpdRespObj
							.setErrorMsg("ERROR:Task not eligible for reassign. Current Status = " + status.toString());
					glpdRespObj.setErrorCode("1");
				}
			}
		} catch (TaskNotFoundException ex) {
			logger.error("Error", ex);
			glpdRespObj.setErrorMsg("ERROR:Task not found");
			glpdRespObj.setErrorCode("1");
		} catch (Exception ex) {
			logger.error("Error", ex);
			glpdRespObj.setErrorMsg("ERROR: Technical Error");
			glpdRespObj.setErrorCode("1");
		}

		logger.info("Exit From reassignTask of OctopodaController");

		return ResponseEntity.status(HttpStatus.CREATED).body(glpdRespObj);
	}

}